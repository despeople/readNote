## Union联合体

```c
//定义枚举类型的作用就是在函数接口中对该函数实现结构体使用联合体中的哪一种数据类型进行判断，枚举类型也就是0，1，2......
typedef enum {
    RING_ITEM_MAT,    // cv::Mat
    RING_ITEM_FRAME,  // MppFrame
    RING_ITEM_NEW_TYPE // 新增的数据类型
} RingItemType;

typedef union {
    cv::Mat mat;
    MppFrame frame;
    NewType new_data; // 新增的数据类型
} RingItem;

typedef struct {
    volatile uint32_t write_index;
    volatile uint32_t read_index;
    RingItemType item_type[RING_BUFFER_SIZE]; // 为每个槽位存储类型标记
    RingItem buffer[RING_BUFFER_SIZE];
} RingBuffer;

```

使用方法：

```c
// 写入时设置类型
buffer.item_type[write_idx] = RING_ITEM_NEW_TYPE;
buffer.buffer[write_idx].new_data = some_value;

// 读取时检查类型，在这里枚举类型的作用就是进行判断检查，因为如果不进行这样操作，联合体是不会在意你到底写入的是哪一种数据格式。
if (buffer.item_type[read_idx] == RING_ITEM_NEW_TYPE) {
    NewType data;
    buffer.buffer[write_idx].new_data = data;
}
//我就算将枚举类型设置成new_type,但是只要我在if语句里面写的是MppFrame格式照样可以写入。枚举类型只是用来进行if判断的。
if (buffer.item_type[read_idx] == RING_ITEM_NEW_TYPE) {
    MppFrame data;
    buffer.buffer[write_idx].new_data = data;
}
```

## 还可以使用**联合体 + 结构体（类型标签内嵌）**

```c
typedef struct {
    enum {
        ITEM_MAT,
        ITEM_FRAME,
        ITEM_NEW_TYPE
    } type;
    union {
        cv::Mat mat;
        MppFrame frame;
        NewType new_data;
    } data;
} RingItem;

typedef struct {
    volatile uint32_t write_index;
    volatile uint32_t read_index;
    RingItem buffer[RING_BUFFER_SIZE];
} RingBuffer;

```

## **C++17 的 `std::variant`**

```c++
#include <variant>

using RingItem = std::variant<cv::Mat, MppFrame, NewType>;

struct RingBuffer {
    volatile uint32_t write_index;
    volatile uint32_t read_index;
    std::array<RingItem, RING_BUFFER_SIZE> buffer;
};

// 使用方法
buffer.buffer[write_idx] = NewType{...};

// 读取时用 std::visit 或 std::holds_alternative
if (std::holds_alternative<NewType>(buffer.buffer[read_idx])) {
    auto& data = std::get<NewType>(buffer.buffer[read_idx]);
}

```

