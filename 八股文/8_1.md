## **注意有符号和无符号的数运算**

**有符号转无符号，运算的时候是补码运算，而不是源码，打印的时候看输出格式**

输出格式如果是使用%d这种有符号输出，那就需要将运算后的补码再转换为原码打印输出，如果是%u这种无符号输出就不需要转换直接输出。因为正数的原码等于补码。但是因为是有符号转无符号所以将符号位的1看为数值位的1。

## %操作必须两边都是整数

## Volatile（编译优化阶段）

作用:告诉编译器该变量是容易发生变化的，不能对该变量进行优化，每次取值都必须从内存中取值而不是直接去取之前在寄存器中的值。

例子：

```c
Volatile int a=20,b,c;

b=a;

c=a;

//代码执行流程如下;

b=a;//先从a的内存中取值存放到寄存器，再把寄存器的值给存到b的内存

c=a;//把寄存器的值给存到b的内存
```

可以看出编译器对c=a这步进行优化，不再执行从a的内存中取值，而是直接从寄存器中取值，如果这段时间内a的发生变化，那么c就不能得到最新的值，这个时候就需要使用volatile告诉编译器，不要对变量a优化，每次都是从内存中取a的值。

## Struct(结构体) （C和C++区别，求结构体大小，使用的注意事项）

1、在c语言中结构体是不允许有函数，在c++中可以，

2、C语言结构体是不可以继承，c++可以继承。

4、访问权限不同

​    在c中默认是公有，不可以修改权限，在c++中权限可以修改

5、在c中不可以初始化数据成员，c++可以初始化

6、c++中空结构体大小为1，C为0

## 大端字节序：高字节存放在低位地址，低字节存放在高地址

## 小端字节序：低字节存放在低位，高字节存放在高位

## 占用空间大小以及字节对齐问题

对于不同位的操作系统，个别数据类型数据大小不一样，

Long 和unsigned long在32位中是4个字节，在64位中是8个字节

  计算的时候需要考虑字节对齐问题：

1. 所占空间必须是成员变量中字节最大的整数倍

2. 每个变量类型的偏移量必须是该变量类型的整数倍

对于联合体，由于所有变量都是共用一块内存，还需注意数组占用最大内存

例如：

```c
Typedef union {double I;int k[5];char c;} DATE;
```

在联合体中成员变量最大为double为8个字节，所以最终大小必须是8的整数倍；又因为联合体是共占内存空间，即int*5=20字节，所以最终为24个字节

在需要进行字节对齐的情况下，就是取最小公约数。

```c
Typedef struct data {int cat;DATE cow; double dog;}too;

//求
sizeof(too);
```

解：在结构体里面联合体为24，联合体的最大类型为8字节，所以联合体的起始位置必须满足偏移量为8的倍数，计算如下：

```
Cat：1-4,
//这里是需要进行偏移，因为是8字节对齐
DATE cow 8+24

Double dog 32+8=40
```

## Enum

没有赋值就是从0开始递增，有赋值后面的数就是赋值数递增，枚举变量可以一样。

## #define和#Typedef

#define:**预处理指令**，只是进行字符串替换，不进行正确性检查。

#Typedef：**关键字**，会进行类型检查，不能在函数里面进行定义。

```c
#define myptr int* p
	myptr a,b;//a是int * a,    b是 int b
	typedef  int*  myptr;
	myptr a,b;//a是int * a,    b是 int* b

//补充：int *p，q表示p是指针变量，q是int变量

```

